#!/usr/bin/env python3
"""
Standalone replica of ns3::BurstSink.

Listens on UDP, receives SeqTsSizeFragHeader-fragmented bursts generated by
`vr_burst_sender.py` (or ns-3), reassembles bursts per source, and optionally
writes each decoded burst to disk.
"""

from __future__ import annotations

import argparse
import os
import socket
import struct
import time
from collections import defaultdict, deque
from dataclasses import dataclass, field
from typing import Deque, Dict, Tuple

HEADER_STRUCT = struct.Struct("!HHQIQ")  # fragSeq, frags, burstSize, seq, timestamp(ns)
HEADER_LEN = HEADER_STRUCT.size  # 24 bytes, matches SeqTsSizeFragHeader


@dataclass
class BurstHandler:
    current_seq: int = 0
    fragments_merged: int = 0
    burst_buffer: bytearray = field(default_factory=bytearray)
    unordered_fragments: Dict[int, bytes] = field(default_factory=dict)

    def reset_for_new_seq(self, seq: int):
        self.current_seq = seq
        self.fragments_merged = 0
        self.unordered_fragments.clear()
        self.burst_buffer = bytearray()


def process_fragment(
    handlers: Dict[Tuple[str, int], BurstHandler],
    addr: Tuple[str, int],
    header: Tuple[int, int, int, int, int],
    payload: bytes,
    local_addr: Tuple[str, int],
    arrival_ns: int,
    raw_len: int,
    bursts_completed: Deque[
        Tuple[Tuple[str, int], Tuple[str, int], bytes, Tuple[int, int, int, int, int], int]
    ],
):
    frag_seq, total_frags, burst_size, burst_seq, timestamp_ns = header
    send_time = timestamp_ns / 1e9
    arrival_time = arrival_ns / 1e9
    delay_ms = (arrival_ns - timestamp_ns) / 1e6
    print(
        f"[FragmentRx] Received fragment {frag_seq}/{total_frags} of burst seq={burst_seq} "
        f"payload={burst_size} B (fragment size={raw_len} B) "
        f"from {format_addr(addr)} to {format_addr(local_addr)} "
        f"at {arrival_time:.9f}s (tx {send_time:.9f}s, delay {delay_ms:.3f} ms)"
    )
    handler = handlers.setdefault(addr, BurstHandler())

    if burst_seq < handler.current_seq:
        return

    if burst_seq > handler.current_seq:
        handler.reset_for_new_seq(burst_seq)

    if frag_seq < handler.fragments_merged:
        return  # duplicate fragment

    if frag_seq == handler.fragments_merged:
        handler.burst_buffer.extend(payload)
        handler.fragments_merged += 1
        # Merge any queued fragments in order
        while handler.fragments_merged in handler.unordered_fragments:
            stored = handler.unordered_fragments.pop(handler.fragments_merged)
            handler.burst_buffer.extend(stored)
            handler.fragments_merged += 1
    else:
        # out-of-order fragment
        handler.unordered_fragments.setdefault(frag_seq, payload)

    if handler.fragments_merged == total_frags:
        if len(handler.burst_buffer) != burst_size:
            print(
                f"[WARN] Burst size mismatch from {addr}: "
                f"{len(handler.burst_buffer)} != {burst_size}"
            )
        bursts_completed.append((addr, local_addr, bytes(handler.burst_buffer), header, arrival_ns))


def format_addr(addr: Tuple[str, int]) -> str:
    return f"{addr[0]}:{addr[1]}"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Receive and reassemble VR bursts (ns3::BurstSink clone)"
    )
    parser.add_argument("--bind-address", default="0.0.0.0", help="Local address to bind")
    parser.add_argument("--bind-port", type=int, required=True, help="Local UDP port to bind")
    parser.add_argument(
        "--stats-interval",
        type=float,
        default=5.0,
        help="Print RX statistics every N seconds (default: 5s, set to 0 to disable)",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((args.bind_address, args.bind_port))
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.setblocking(True)

    handlers: Dict[Tuple[str, int], BurstHandler] = {}
    bursts_completed: Deque[
        Tuple[Tuple[str, int], Tuple[str, int], bytes, Tuple[int, int, int, int, int], int]
    ] = deque()

    total_bytes = 0
    total_frags = 0
    total_bursts = 0
    last_stats = time.time()

    print(
        f"[INFO] Listening on {args.bind_address}:{args.bind_port}. "
        "Waiting for VR bursts..."
    )
    burst_file_index = 0

    while True:
        data, addr = sock.recvfrom(65535)
        arrival_ns = time.time_ns()
        if len(data) < HEADER_LEN:
            print(f"[WARN] Dropping short packet from {addr} (len={len(data)})")
            continue

        header = HEADER_STRUCT.unpack_from(data)
        payload = data[HEADER_LEN:]

        total_bytes += len(data)
        total_frags += 1
        local_addr = sock.getsockname()
        process_fragment(
            handlers, addr, header, payload, local_addr, arrival_ns, len(data), bursts_completed
        )

        while bursts_completed:
            src, dst, burst_payload, hdr, burst_arrival_ns = bursts_completed.popleft()
            total_bursts += 1
            frag_seq, frags, burst_size, burst_seq, timestamp_ns = hdr
            send_time = timestamp_ns / 1e9
            arrival_time = burst_arrival_ns / 1e9
            delay_ms = (burst_arrival_ns - timestamp_ns) / 1e6
            print(
                f"[BurstRx] Completed burst seq={burst_seq} payload={len(burst_payload)} B "
                f"across {frags} fragments from {format_addr(src)} to {format_addr(dst)} "
                f"at {arrival_time:.9f}s (tx {send_time:.9f}s, delay {delay_ms:.3f} ms)"
            )
        if args.stats_interval > 0:
            now = time.time()
            if now - last_stats >= args.stats_interval:
                print(
                    f"[STATS] {total_frags} fragments / {total_bursts} bursts "
                    f"received ({total_bytes / 1e6:.2f} MB)"
                )
                last_stats = now


if __name__ == "__main__":
    main()
